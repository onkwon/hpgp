#include "CppUTest/TestHarness.h"
#include "CppUTestExt/MockSupport.h"

#include "hpgp.h"

#define MME_HEADER_LEN		\
	(sizeof(struct hpgp_frame) + sizeof(struct hpgp_mme))

TEST_GROUP(HPGP) {
	void setup(void) {
	}
	void teardown(void) {
		mock().checkExpectations();
		mock().clear();
	}
};

TEST(HPGP, SET_KEY_REQ) {
	uint8_t expected[] = {
		0x01,0x08,0x60,0x00,0x00,0x01,0xaa,0xaa,
		0xaa,0xaa,0x00,0x00,0x00,0x00,0x04,0x00,
		0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,
		0x06,0x07,0x01,0x00,0x01,0x02,0x03,0x04,
		0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,
		0x0d,0x0e,0x0f,0x00,0x00,0x00
	};

	uint8_t buf[64];
	struct hpgp_mme_setkey_req req = {
		.key_type = 1, /* NMK */
		.my_nonce = 0xaaaaaaaa,
		.your_nonce = 0,
		.pid = 4, /* HLE */
		.prn = 0,
		.pmn = 0,
		.cco = 0, /* station */
		.nid = { 0x01,0x02,0x03,0x04,0x05,0x06,0x07 },
		.key_selection = 1, /* nmk known to station */
		.key = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 },
	};
	const size_t len = hpgp_pack_request(HPGP_MMTYPE_SET_KEY,
			&req, buf, sizeof(buf));

	LONGS_EQUAL(41, len);
	MEMCMP_EQUAL(expected, buf, len + MME_HEADER_LEN);
}

TEST(HPGP, GET_KEY_REQ) {
	uint8_t expected[] = {
		0x01,0x0c,0x60,0x00,0x00,0x00,0x01,0x01,
		0x02,0x03,0x04,0x05,0x06,0x07,0xaa,0xaa,
		0xaa,0xaa,0x04,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00
	};

	uint8_t buf[64];
	struct hpgp_mme_getkey_req req = {
		.req_type = 0, /* direct */
		.key_type = 1, /* NMK */
		.nid = { 0x01,0x02,0x03,0x04,0x05,0x06,0x07 },
		.my_nonce = 0xaaaaaaaa,
		.pid = 4, /* HLE */
		.prn = 0,
		.pmn = 0,
	};
	const size_t len = hpgp_pack_request(HPGP_MMTYPE_GET_KEY,
			&req, buf, sizeof(buf));

	LONGS_EQUAL(41, len);
	MEMCMP_EQUAL(expected, buf, len + MME_HEADER_LEN);
}

TEST(HPGP, GET_KEY_CNF) {
	uint8_t expected[] = {
		0x01,0x0d,0x60,0x00,0x00,0x00,0x01,0x55,
		0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x01,
		0x02,0x03,0x04,0x05,0x06,0x07,0x00,0x04,
		0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,
		0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,
		0x0d,0x0e,0x0f,0x00,0x00,0x00
	};

	uint8_t buf[64];
	struct hpgp_mme_getkey_cnf cnf = {
		.result = 0,
		.key_type = 1, /* NMK */
		.my_nonce = 0x55555555,
		.your_nonce = 0xaaaaaaaa,
		.nid = { 0x01,0x02,0x03,0x04,0x05,0x06,0x07 },
		.eks = 0,
		.pid = 4, /* HLE */
		.prn = 0,
		.pmn = 0,
		.key = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 },
	};
	const size_t len = hpgp_pack_confirm(HPGP_MMTYPE_GET_KEY,
			&cnf, buf, sizeof(buf));

	LONGS_EQUAL(41, len);
	MEMCMP_EQUAL(expected, buf, len + MME_HEADER_LEN);
}

TEST(HPGP, SLAC_PARM_CNF) {
	uint8_t expected[] = {
		0x01,0x65,0x60,0x00,0x00,0xff,0xff,0xff,
		0xff,0xff,0xff,0x0a,0x06,0x01,0x00,0xe0,
		0x4c,0x36,0x07,0x91,0x00,0x00,0x00,0xe0,
		0x4c,0x36,0x07,0x91,0x00,0x01,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,
	};

	uint8_t buf[64];
	struct hpgp_mme_slac_parm_cnf cnf = {
		.target_mac = { 0xff,0xff,0xff,0xff,0xff,0xff },
		.nr_sounds = 10,
		.timeout_ms_hundredth = 6,
		.forwarding_type = 1,
		.app_type = 0, /* PEV-EVSE association */
		.sec_type = 0, /* No security */
		.ciphersuite = 0,
		.forwarding_mac = { 0x00,0xe0,0x4c,0x36,0x07,0x91 },
		.run_id = { 0x00,0xe0,0x4c,0x36,0x07,0x91,0x00,0x01 },
	};
	const size_t len = hpgp_pack_confirm(HPGP_MMTYPE_SLAC_PARM,
			&cnf, buf, sizeof(buf));

	LONGS_EQUAL(41, len);
	MEMCMP_EQUAL(expected, buf, len + MME_HEADER_LEN);
}

TEST(HPGP, ATTEN_CHAR_IND) {
	uint8_t expected[] = {
		0x01,0x6e,0x60,0x00,0x00,0x00,0x00,0x00,
		0xe0,0x4c,0x36,0x07,0x91,0x00,0xe0,0x4c,
		0x36,0x07,0x91,0x00,0x01,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,
		0x3a,0x16,0x15,0x16,0x1a,0x17,0x18,0x1c,
		0x18,0x18,0x19,0x17,0x17,0x17,0x17,0x17,
		0x17,0x16,0x17,0x17,0x17,0x17,0x17,0x16,
		0x17,0x16,0x16,0x16,0x16,0x17,0x17,0x17,
		0x17,0x17,0x17,0x18,0x18,0x18,0x19,0x18,
		0x19,0x19,0x1a,0x19,0x19,0x19,0x1a,0x18,
		0x18,0x18,0x1b,0x1a,0x19,0x19,0x18,0x17,
		0x17,0x18,0x24,
	};

	uint8_t buf[256];
	struct hpgp_mme_atten_char_ind ind = {
		.atten = {
			.nr_sounds = 3,
			.nr_groups = 58,
			.run_id = { 0x00,0xe0,0x4c,0x36,0x07,0x91,0x00,0x01 },
			.mac_src = { 0x00,0xe0,0x4c,0x36,0x07,0x91 },
			.aag = { 0x16, 0x15, 0x16, 0x1a, 0x17, 0x18, 0x1c, 0x18,
				0x18, 0x19, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
				0x16, 0x17, 0x17, 0x17, 0x17, 0x17, 0x16, 0x17,
				0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
				0x17, 0x17, 0x18, 0x18, 0x18, 0x19, 0x18, 0x19,
				0x19, 0x1a, 0x19, 0x19, 0x19, 0x1a, 0x18, 0x18,
				0x18, 0x1b, 0x1a, 0x19, 0x19, 0x18, 0x17, 0x17,
				0x18, 0x24
			},
		},
	};

	const size_t len = hpgp_pack_indication(HPGP_MMTYPE_ATTEN_CHAR,
			&ind, buf, sizeof(buf));

	LONGS_EQUAL(110, len);
	MEMCMP_EQUAL(expected, buf, len + MME_HEADER_LEN);
}

TEST(HPGP, ATTEN_CHAR_RSP) {
	uint8_t expected[] = {
		0x01,0x6f,
		0x60,0x00,0x00,0x00,0x00,0x00,0x11,0x22,
		0x33,0x44,0x55,0x00,0xe0,0x4c,0x36,0x07,
		0x91,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	};

	uint8_t buf[256];
	struct hpgp_mme_atten_char_rsp rsp = {
		.app_type = 0,
		.sec_type = 0,
		.atten = {
			.mac_src = { 0x00,0x11,0x22,0x33,0x44,0x55 },
			.run_id = { 0x00,0xe0,0x4c,0x36,0x07,0x91,0x00,0x01 },
			//.id_src =
			//.id_rsp =
			.result = 0,
		},
	};

	const size_t len = hpgp_pack_response(HPGP_MMTYPE_ATTEN_CHAR,
			&rsp, buf, sizeof(buf));
	LONGS_EQUAL(51, len);
	MEMCMP_EQUAL(expected, buf, len + MME_HEADER_LEN);
}

TEST(HPGP, SLAC_MATCH_REQ) {
	uint8_t expected[] = {
		0x01,0x7c,
		0x60,0x00,0x00,0x00,0x00,0x3e,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0xe0,0x4c,0x36,0x07,0x91,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x11,0x22,0x33,0x44,0x55,0x00,0xe0,0x4c,
		0x36,0x07,0x91,0x00,0x01,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00
	};

	uint8_t buf[256];
	struct hpgp_mme_slac_match_req req = {
		.app_type = 0,
		.sec_type = 0,
		.len = 62,
		.mfield = {
			//.id_pev =
			//.id_evse =
			.mac_pev = { 0x00,0xe0,0x4c,0x36,0x07,0x91 },
			.mac_evse = { 0x00,0x11,0x22,0x33,0x44,0x55 },
			.run_id = { 0x00,0xe0,0x4c,0x36,0x07,0x91,0x00,0x01 },
		},
	};

	const size_t len = hpgp_pack_request(HPGP_MMTYPE_SLAC_MATCH,
			&req, buf, sizeof(buf));
	LONGS_EQUAL(66, len);
	MEMCMP_EQUAL(expected, buf, len + MME_HEADER_LEN);
}

TEST(HPGP, SLAC_MATCH_CNF) {
	uint8_t expected[] = {
		0x01,0x7d,
		0x60,0x00,0x00,0x00,0x00,0x56,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0xe0,0x4c,0x36,0x07,0x91,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,
		0x22,0x33,0x44,0x55,0x66,0x00,0xe0,0x4c,
		0x36,0x07,0x91,0x00,0x01,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,
		0x04,0x05,0x06,0x07,0x00,0x00,0x01,0x02,
		0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,
		0x0b,0x0c,0x0d,0x0e,0x0f,
	};

	uint8_t buf[256];
	struct hpgp_mme_slac_match_cnf cnf = {
		.app_type = 0,
		.sec_type = 0,
		.len = sizeof(struct hpgp_mme_slac_match_cnf_body),
		.mfield = {
			.nid = { 0x01,0x02,0x03,0x04,0x05,0x06,0x07 },
			.nmk = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 },
			.mac_evse = { 0x11,0x22,0x33,0x44,0x55,0x66 },
			.run_id = { 0x00,0xe0,0x4c,0x36,0x07,0x91,0x00,0x01 },
			.mac_pev = { 0x00,0xe0,0x4c,0x36,0x07,0x91 },
		},
	};

	const size_t len = hpgp_pack_confirm(HPGP_MMTYPE_SLAC_MATCH,
			&cnf, buf, sizeof(buf));
	LONGS_EQUAL(90, len);
	MEMCMP_EQUAL(expected, buf, len + MME_HEADER_LEN);
}

TEST(HPGP, START_ATTEN_CHAR_IND) {
	uint8_t expected[] = {
		0x01,0x6a,
		0x60,0x00,0x00,0x00,0x00,0x0a,0x06,0x00,
		0x00,0xe0,0x4c,0x36,0x07,0x91,0x00,0xe0,
		0x4c,0x36,0x07,0x91,0x00,0x01,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,
	};

	uint8_t buf[256];
	struct hpgp_mme_start_atten_char_ind ind = {
		.app_type = 0,
		.sec_type = 0,
		.atten = {
			.nr_sounds = 10,
			.timeout_ms_hundredth = 6,
			.resp_type = 0,
			.forwarding_sta = { 0x00,0xe0,0x4c,0x36,0x07,0x91 },
			.run_id = { 0x00,0xe0,0x4c,0x36,0x07,0x91,0x00,0x01 },
		},
	};

	const size_t len = hpgp_pack_indication(HPGP_MMTYPE_START_ATTEN_CHAR,
			&ind, buf, sizeof(buf));
	LONGS_EQUAL(41, len);
	MEMCMP_EQUAL(expected, buf, len + MME_HEADER_LEN);
}

TEST(HPGP, MNBC_SOUND_IND) {
	uint8_t expected[] = {
		0x01,0x76,
		0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x09,0x00,
		0xe0,0x4c,0x36,0x07,0x91,0x00,0x01,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
		0xff,0xff,0xff,0xff,0xff,0xff,0xff,
	};

	uint8_t buf[256];
	struct hpgp_mme_mnbc_sound_ind ind = {
		.app_type = 0,
		.sec_type = 0,
		.msound = {
			//.sender_id =,
			.count = 9,
			.run_id = { 0x00,0xe0,0x4c,0x36,0x07,0x91,0x00,0x01 },
			.rnd = { 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
				0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff },
		},
	};

	const size_t len = hpgp_pack_indication(HPGP_MMTYPE_MNBC_SOUND,
			&ind, buf, sizeof(buf));
	LONGS_EQUAL(52, len);
	MEMCMP_EQUAL(expected, buf, len + MME_HEADER_LEN);
}
